# 1463: 1로 만들기
- 출처: <https://www.acmicpc.net/problem/1463>
- 분류: [동적 계획법(DP)](https://github.com/irondrum-bell/TIL/blob/master/DataStructure/Dynamic-Programming.md)

## 문제 개요

### 문제
정수 X에 사용할 수 있는 연산은 다음과 같이 세 가지 이다.
> 1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
> 2. X가 2로 나누어 떨어지면, 2로 나눈다.
> 3. 1을 뺀다.
>
정수 N이 주어졌을 때, 위와 같은 연산 세 개를 적절히 사용해서 1을 만들려고 한다. 연산을 사용하는 횟수의 최솟값을 출력하시오.

### 입력
첫째 줄에 1보다 크거나 같고, 10^6보다 작거나 같은 정수 X이 주어진다.

### 출력
첫째 줄에 연산을 하는 횟수의 최솟값을 출력한다.

### 테스트 케이스
![테스트 케이스](/assets/boj-1463-testcase.PNG)

#### 설명
1. 2 -> 1 로 1회 연산으로 1을 만들 수 있다.
2. 10의 경우 10 -> 5 -> 4 -> 2 -> 1 보다 10 -> 9 -> 3 -> 1 이 연산 횟수가 1이 더 적다.

## 풀이

### 접근
동적 계획법과 관련된 처음 풀어본 문제.  
동적 계획법의 개념에 대해서 전혀 모르고 문제 풀이를 시도하였고 그래서 단순히 문제에 나오는 연산 조건 세 개를 조건문으로 구현 함.  
결과는 테스트 케이스 2의 설명처럼 나누기 2가 먼저 연산되어 '최소 연산 횟수'라는 조건을 만족하지 못 함.  
이 후 세 가지 연산에 우선 순위도 줬고 다른 조건도 추가했지만 결국 해결하지 못 함.  
검색을 통해 동적 계획법의 개념에 대해 어느 정도 이해하고 다른 사람의 풀이를 통해 적용법을 익힘.

### 구현
처음 접근 했던 방법 대로 구현한 코드
```c++
#include <cstdio>
using namespace std;

int main() {
  int N;
  scanf("%d", &N);
  int answer = 0;
  while(true) {
    if(N == 1)
      break;
    if(N % 3 == 0)
      N /= 3;
    else if(N % 2 == 0)
      N /= 2;
    else 
      N -= 1;
    answer++;
  }
    printf("%d", answer);
}
```

검색으로 해답을 확인한 후 그대로 구현해 본 코드 (<https://blockdmask.tistory.com/254>)
```c++
#include <cstdio>
#include <algorithm>
using namespace std;

int main() {
  int X;
  int arr[1000001];
  scanf("%d", &X);
  arr[1] = 0;

  for(int i = 2; i <= X; i++) {
    arr[i] = arr[i - 1] + 1;
    if(i % 2 == 0)
      arr[i] = min(arr[i], arr[i/2] + 1);
    if(i % 3 == 0)
      arr[i] = min(arr[i], arr[i/3] + 1);
  }
  printf("%d", arr[X]);
}
```

### 복습
- 동적 계획법은 주어진 문제를 여러 작은 문제로 나눈 뒤 각 작은 문제를 풀며 그 해답으로 원 문제를 해결하는 방식.
- 배열을 사용하여 배열의 index = 수, 배열의 값 = 해당하는 수(index)에 도달하기 위한 최소 연산 횟수를 저장하여 N까지 계산해 나간다.
- **1일 때 최소 연산 횟수는 0**임을 이용해 2, 3 ... X까지 Bottom-Up 방식으로 각 숫자가 되기 위한 최소 연산 횟수를 세 가지 연산 조건을 역순으로 적용해 구함.
> 1. 이전 수 에서 1을 더함
> 2. 2로 나누어 떨어지는 숫자라면 나누어진 수에서 곱하기 2를 함
> 3. 3으로 나누어 떨어지는 숫자라면 나누어진 수에서 곱하기 3을 함.
>
- 세 가지 조건중 가장 최소가 되는 경우를 구하고 선택된 경우의 값에는 해당 수에 도달하기 위한 최소 연산 횟수가 저장되어 있으므로 그 값에 + 1을 하면 현재 수에 도달하기 위한 최소 연산 횟수가 구해짐.

### 다른 풀이
1. 재귀함수를 사용해 구현
    - 재귀함수와 이진 탐색 트리 아니면 BFS를 사용한 것 같은데 아직 해당 알고리즘에 개념이 없어서 정확히 알진 못함
    - 해당 값을 만들기 위해 곱하기 2를 한 경우와 곱하기 3을 한 경우 중 최소를 선택
    - 나머지 연산을 통해 더하기 1을 해야하는 경우도 한번에 고려함
```c++
int dp(int a){
	if (a <= 1)
		return  0;
	return min(dp(a / 2) + a % 2 + 1, dp(a / 3) + a % 3 + 1);
}
```

2. 큐와 BFS를 사용
    - <https://blockdmask.tistory.com/257>
    - Top-Down 방식으로 주어진 X에 세 가지 연산 조건을 적용해가며 그 값과 횟수의 쌍으로 큐에 저장
    - 세 가지 연산을 적용한 경우는 Dequeue하며 값이 처음 1이 될 때까지 반복
    - boolean 배열을 사용하여 이미 연산을 적용해봤던 값들을 저장하여 추후 중복 연산을 피함(이미 연산이 적용된 값이면 해당 값에 도달하기 위한 최소 연산 횟수가 저장되어 있음)
